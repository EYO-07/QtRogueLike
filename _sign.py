# --- From file: ./QtRogueLike/globals_variables.py (183 lines) ---
def Generate_Square_Diffs(radius=3): ...
def d(a, b=None): ...
def rn(num=5): ...
MAP_WIDTH = 70
MAP_HEIGHT = 70
TILE_SIZE = 70
VIEW_WIDTH_IN_TILES = 7
VIEW_HEIGHT_IN_TILES = 7
PLAYER_MAX_HP = 100
PLAYER_MAX_STAMINA = 200
PLAYER_MAX_HUNGER = 1000
PROD_INV_FACTOR = 100.0
ADJACENT_DIFF_MOVES = [(1, 0), (-1, 0), (0, 1), (0, -1), (0, 0)]
CHESS_KNIGHT_DIFF_MOVES = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
SQUARE_DIFF_MOVES = Generate_Square_Diffs(2)
CROSS_DIFF_MOVES = [(0, 1), (0, 2), (0, 3), (0, -1), (0, -2), (0, -3), (1, 0), (2, 0), (3, 0), (-1, 0), (-2, 0), (-3, 0)]
SPRITE_NAMES_WEAPONS = ['club', 'long_sword', 'bastard_sword', 'mace', 'wand', 'staff']
SPRITE_NAMES_PLAYABLES = ['player', 'player_2', 'player_3']
SPRITE_NAMES_CHARACTERS = SPRITE_NAMES_PLAYABLES + ['zombie', 'bear', 'enemy', 'rogue', 'mercenary', 'swordman', 'mounted_knight']
SPRITE_NAMES_FOODS = ['food', 'apple', 'fish', 'bread', 'meat']
SPRITE_NAMES_TILES = ['grass', 'dirt', 'floor', 'wall', 'tree', 'water', 'stair_up', 'stair_down', 'dungeon_entrance', 'shallow_water', 'rock']
SPRITE_NAMES = SPRITE_NAMES_WEAPONS + SPRITE_NAMES_CHARACTERS + SPRITE_NAMES_FOODS + SPRITE_NAMES_TILES + ['sack', 'HUD_arrow', 'whetstone', 'house', 'castle', 'lumber_mill', 'quarry', 'mill', 'wood', 'tower']
EQUIPMENT_SLOTS = ['primary_hand', 'secondary_hand', 'head', 'neck', 'torso', 'waist', 'legs', 'foot']
LOOT_TABLE = [{'item_name': 'Food', 'chance': 0.3, 'name': 'apple', 'nutrition': 10}, {'item_name': 'Food', 'chance': 0.2, 'name': 'fish', 'nutrition': 80}, {'item_name': 'Food', 'chance': 0.1, 'name': 'bread', 'nutrition': 50}, {'item_name': 'Food', 'chance': 0.01, 'name': 'meat', 'nutrition': 280}, {'item_name': 'Sword', 'chance': 0.001, 'name': 'Long_Sword', 'damage': 12, 'durability_factor': 0.998}, {'item_name': 'Sword', 'chance': 0.2, 'name': 'Long_Sword', 'damage': 10, 'durability_factor': 0.95}, {'item_name': 'Sword', 'chance': 0.1, 'name': 'Long_Sword', 'damage': 10, 'durability_factor': 0.8}, {'item_name': 'WeaponRepairTool', 'chance': 0.01, 'name': 'Whetstone', 'uses': 10}]
DUNGEON_ENEMY_TABLE = [{'enemy': 'Mercenary', 'chance': 0.1, 'b_generate_items': True, 'extra_items': [{'item_name': 'WeaponRepairTool', 'name': 'Whetstone', 'uses': 5}, {'item_name': 'Food', 'name': 'meat', 'nutrition': 250}]}, {'enemy': 'Rogue', 'chance': 0.3, 'b_generate_items': True, 'extra_items': [{'item_name': 'WeaponRepairTool', 'name': 'Whetstone', 'uses': 3}, {'item_name': 'Food', 'name': 'meat', 'nutrition': 200}]}, {'enemy': 'Zombie', 'chance': 0.75, 'b_generate_items': True}]
FOREST_ENEMY_TABLE = [{'enemy': 'Bear', 'chance': 0.07, 'b_generate_items': True}, {'enemy': 'Mercenary', 'chance': 0.05, 'b_generate_items': True, 'extra_items': [{'item_name': 'WeaponRepairTool', 'name': 'Whetstone', 'uses': 5}, {'item_name': 'Food', 'name': 'meat', 'nutrition': 250}]}, {'enemy': 'Rogue', 'chance': 0.3, 'b_generate_items': True, 'extra_items': [{'item_name': 'WeaponRepairTool', 'name': 'Whetstone', 'uses': 2}]}, {'enemy': 'Zombie', 'chance': 0.75, 'b_generate_items': True}]
FIELD_ENEMY_TABLE = [{'enemy': 'Bear', 'chance': 0.03, 'b_generate_items': True}, {'enemy': 'Rogue', 'chance': 0.05, 'b_generate_items': True}, {'enemy': 'Zombie', 'chance': 0.9, 'b_generate_items': True}]
DEFAULT_ENEMY_TABLE = [{'enemy': 'Bear', 'chance': 0.03, 'b_generate_items': True}, {'enemy': 'Rogue', 'chance': 0.05, 'b_generate_items': True}, {'enemy': 'Zombie', 'chance': 0.9, 'b_generate_items': True}]
ROAD_ENEMY_TABLE = [{'enemy': 'Rogue', 'chance': 0.1, 'b_generate_items': True}, {'enemy': 'Zombie', 'chance': 0.9, 'b_generate_items': True}]
LAKE_ENEMY_TABLE = [{'enemy': 'Rogue', 'chance': 0.25, 'b_generate_items': True}, {'enemy': 'Zombie', 'chance': 0.75, 'b_generate_items': True}]

# --- From file: ./QtRogueLike/start.pyw (208 lines) ---
def add_alias(alias, root): ...
def is_node_import_restricted(node): ...
def is_node_call_restricted(node): ...
def is_node_attr_restricted(node): ...
def is_node_dynamic_import(node): ...
def is_node_string_injection_with_dynamic_import(node): ...
def is_module_safe(path): ...
def import_module_from_path(path, module_name=None): ...

# --- From file: ./QtRogueLike/game.py (1241 lines) ---
class Game_SOUNDMANAGER:
    def __init__(self): ...
    def get_random_music_filename(self, directory='music', pattern=''): ...
    def load_music(self, music_path): ...
    def load_random_music(self): ...
    def handle_media_status(self, status): ...
    def toggle_music(self): ...
class Game_VIEWPORT:
    def __init__(self): ...
    def draw(self): ...
    def draw_grid(self): ...
    def draw_hud(self): ...
    def rotate_vector_for_camera(self, dx, dy): ...
    def rotate_vector_for_movement(self, dx, dy): ...
    def rotated_direction(self, dx, dy): ...
class Game_PLAYERS:
    def __init__(self): ...
    def add_player(self, key, **kwargs): ...
    def set_player(self, name): ...
    def set_player_name(self, key, new_name): ...
    def place_players(self): ...
    def remove_player(self, key=None): ...
    def update_prior_next_selection(self): ...
    def move_party(self): ...
    def release_party(self, diff_moves=CROSS_DIFF_MOVES_1x1): ...
    def count_party(self): ...
class Game_MAPTRANSITION:
    def __init__(self): ...
    def player_new_x_y_horizontal(self, out_of_bounds_x, out_of_bounds_y): ...
    def find_stair_tile(self, map_obj, target_stair_coords): ...
    def new_map_from_current_coords(self, filename='default', prev_coords=None, up=False): ...
    def map_transition(self, new_map_file, new_map_coord, map_type, prv_coords=None, going_up=False): ...
    def safely_place_character_to_new_map(self, char=None): ...
    def horizontal_map_transition(self, x, y): ...
    def vertical_map_transition(self, target_map_coords, up): ...
class Game_DATA:
    def __init__(self): ...
    def from_dict(self, dictionary): ...
    def start_new_game(self, new_character_name='Main Character', b_clear_players=True): ...
    def save_current_game(self, slot=1): ...
    def try_load_map_or_create_new(self): ...
    def load_current_game(self, slot=1): ...
class Game_GUI:
    def __init__(self): ...
    def add_message(self, message, turns=15): ...
    def update_messages(self): ...
    def update_inv_window(self): ...
    def take_note_on_diary(self): ...
class Game_ITERATION:
    def __init__(self): ...
    def game_iteration(self): ...
    def process_events(self): ...
    def update_players(self): ...
    def update_enemies(self): ...
    def update_buildings(self): ...
    def Event_NewTurn(self): ...
    def Event_NewDay(self): ...
    def Event_PlayerDeath(self): ...
    def Event_DoAttack(self, event): ...
    def Event_CharacterDeath(self, event): ...
class Game:
    def __init__(self): ...
    def closeEvent(self, event): ...
    def resizeEvent(self, event): ...
    def keyReleaseEvent(self, event): ...
    def keyPressEvent(self, event): ...

# --- From file: ./QtRogueLike/reality.py (1369 lines) ---
def is_enemy_of(char1, char2): ...
class Entity:
    def __init__(self): ...
    def get_sprite(self): ...
    def paint_to(self, painter): ...
class Resource:
    def __init__(self): ...
    def get_value(self): ...
    def update_value(self): ...
    def store(self, char, tile_building): ...
class SpecialSkillWeapon:
    def __init__(self): ...
    def consumption(self, char, type): ...
    def damage(self, type): ...
    def special_attack(self, char, target_tile, game, type='knight'): ...
    def use_power_special(self, char, game): ...
    def use_thrust_special(self, char, game): ...
    def use_knight_special(self, char, game): ...
    def use_tower_special(self, char, game): ...
    def use_bishop_special(self, char, game): ...
    def use_special(self, char, game): ...
class Item:
    def __init__(self, name='', description='', weight=1, sprite='item'): ...
    def __str__(self): ...
class Usable:
    def __init__(self, name='', description='', weight=1, sprite='item', uses=1): ...
    def use(self, char): ...
class Container:
    def __init__(self, current_char=None): ...
    def get_item_index(self, item): ...
    def add_item(self, item): ...
    def remove_item(self, item): ...
    def add_item_by_chance(self, item_name, chance=0.1, *args, **kwargs): ...
class Equippable:
    def __init__(self, name='', description='', weight=1, slot='primary_hand', durability_factor=0.995): ...
    def get_equipped_slot(self, char): ...
    def durability_consumption(self, char): ...
class Weapon:
    def __init__(self, name='', damage=0, description='', weight=1, stamina_consumption=1, durability_factor=0.995): ...
    def durability_consumption(self, char): ...
    def stamina_consumption(self, char): ...
    def stats_update(self, player): ...
class Parriable:
    def __init__(self, name='', damage=0, description='', weight=1, stamina_consumption=1, durability_factor=0.995): ...
    def get_parry_chance(self, char, enemy, damage): ...
class Sword:
    def __init__(self, name='long_sword', damage=8, description='', weight=1, stamina_consumption=1, durability_factor=0.995): ...
    def get_parry_chance(self, player, enemy, damage): ...
class Mace:
    def __init__(self, name='mace', damage=10, description='', weight=1, stamina_consumption=2, durability_factor=0.995): ...
    def get_parry_chance(self, player, enemy, damage): ...
class Food:
    def __init__(self, name='', nutrition=0, description='', weight=1): ...
    def use(self, char): ...
    def update_value(self): ...
class Wood:
    def __init__(self, value=100): ...
class Stone:
    def __init__(self, value=100): ...
class Metal:
    def __init__(self, value=100): ...
class WeaponRepairTool:
    def __init__(self, name='', repairing_factor=1.05, description='', weight=1, uses=10): ...
    def use(self, char): ...
class Armor:
    def __init__(self, name='', defense_factor=0.02, description='', weight=1, slot='torso'): ...
class NPC:
    def __init__(self): ...
    def get_closest_visible(self, entities, game_instance): ...
    def find_target(self, entities, game_instance, enemy_tolerance=4): ...
    def random_walk(self, game_instance, activity=0.3): ...
    def playable_update(self, game_instance, tolerance=4, activity=0.05): ...
    def enemy_update(self, game_instance, tolerance=25, activity=0.3): ...
class Character:
    def __init__(self, name='', hp=100, x=50, y=50): ...
    def reset_stats(self): ...
    def equip_item(self, item, slot): ...
    def unequip_item(self, slot): ...
    def pickup_item(self, item): ...
    def move(self, dx, dy, game_map): ...
    def drop_on_death(self): ...
    def calculate_damage_done(self): ...
    def calculate_damage_received(self, damage, attacker): ...
    def generate_initial_items(self): ...
    def turn_update(self, game_turns_counter): ...
    def can_see_character(self, another, game_map): ...
    def use_first_item_of(self, item_class_name, game_instance): ...
    def set_equipment_by_slot(self, value, slot='primary_hand'): ...
class Player:
    def __init__(self, name='', hp=PLAYER_MAX_HP, x=MAP_WIDTH // 2, y=MAP_HEIGHT // 2, b_generate_items=False, sprite='player', current_map=(0, 0, 0)): ...
    def move(self, dx, dy, game_map): ...
    def calculate_damage_done(self): ...
    def regenerate_stamina(self): ...
    def regenerate_health(self): ...
    def generate_initial_items(self): ...
    def get_forward_direction(self): ...
    def _normalize(self, v): ...
    def is_in_cone_vision(self, observer, point, direction=(0, -1), fov_deg=180): ...
    def can_see_character(self, another, game_map): ...
    def reset_stats(self): ...
    def calculate_defense_factor(self): ...
    def is_rendered_on_map(self, game_map): ...
    def is_placed_on_map(self, game_map): ...
    def update(self, game_instance): ...
class Enemy:
    def __init__(self, name='', hp=30, x=50, y=50, b_generate_items=False): ...
    def calculate_damage_done(self): ...
    def calculate_damage_received(self, damage, attacker): ...
    def update(self, player, map, game): ...
    def generate_initial_items(self): ...
class Prey:
class Zombie:
    def __init__(self, name='', hp=40, x=50, y=50, b_generate_items=False): ...
    def calculate_damage_done(self): ...
    def generate_initial_items(self): ...
class Rogue:
    def __init__(self, name='', hp=100, x=50, y=50, b_generate_items=False): ...
    def calculate_damage_done(self): ...
    def generate_initial_items(self): ...
class Mercenary:
    def __init__(self, name='', hp=130, x=50, y=50, b_generate_items=False): ...
    def calculate_damage_done(self): ...
    def generate_initial_items(self): ...
class Bear:
    def __init__(self, name='', hp=60, x=50, y=50, b_generate_items=False, dbg_blind=False): ...
    def calculate_damage_done(self): ...
    def generate_initial_items(self): ...
    def can_see_character(self, another, game_map): ...
class Dear:
class Tile:
    SPRITES = {}
    def __init__(self, walkable=True, sprite_key='grass'): ...
    def add_layer(self, sprite_key): ...
    def remove_layer(self, sprite_key=None): ...
    def draw(self, scene, x, y, tile_size=TILE_SIZE): ...
    def can_place_character(self): ...
    def _try_load(cls, key): ...
    def _load_sprites(cls): ...
    def get_default_pixmap(self): ...
    def add_cosmetic_sprite(self, sprite_key=None): ...
class ActionTile:
    def __init__(self, front_sprite, walkable=True, sprite_key='grass'): ...
class Stair:
class TileBuilding:
    def __init__(self, front_sprite, walkable=True, sprite_key='grass'): ...
    def production(self): ...
    def update(self): ...
    def retrieve_food(self, game_instance, quantity=500): ...
    def retrieve_wood(self, game_instance, quantity=500): ...
    def retrieve_metal(self, game, quantity=500): ...
    def retrieve_stone(self, game, quantity=500): ...
    def store_resource(self, res, game_instance): ...
    def menu_garrison(self, current_menu, current_item, menu_instance, game_instance): ...
    def menu_resources(self, current_menu, current_item, menu_instance, game_instance): ...
class Castle:
    def __init__(self, name='Home'): ...
    def production(self): ...
    def action(self): ...
    def update_menu_list(self, selection_box_instance=None): ...
    def new_npc(self, game_instance): ...
    def new(cls, game_instance, x=None, y=None): ...
class Mill:
    def __init__(self, name='Farm', food=d(500, 2000)): ...
    def action(self): ...
    def update_menu_list(self, selection_box_instance=None): ...
    def production(self): ...
class LumberMill:
    def __init__(self, name='Lumber Mill', wood=d(500, 2000)): ...
    def action(self): ...
    def update_menu_list(self, selection_box_instance=None): ...
    def production(self): ...
class GuardTower:
    def __init__(self, name='Guard Tower'): ...
    def action(self): ...
    def update_menu_list(self, selection_box_instance=None): ...
    def new_swordman(self, game_instance): ...
    def new_mounted_knight(self, game_instance): ...
    def production(self): ...

# --- From file: ./QtRogueLike/gui.py (1034 lines) ---
def quality(game_item): ...
def info(game_item): ...
class JournalWindow:
    def __init__(self, parent=None): ...
    def whereAmI(self): ...
    def update_position(self): ...
    def save_journal(self): ...
    def log_diary_entry(self): ...
    def log_quick_diary_entry(self): ...
    def keyPressEvent(self, event): ...
    def showEvent(self, event): ...
    def append_text(self, text): ...
    def clear_text(self): ...
    def load_journal(self, slot=1): ...
    def keyPressEvent(self, event): ...
class MessagePopup:
    def __init__(self, parent=None): ...
    def set_message(self, messages): ...
class SelectionBox:
    def __init__(self, item_list=[f'Option {i}' for i in range(5)], action=lambda x, instance: instance.close(), parent=None, **kwargs): ...
    def get_current_list(self): ...
    def add_list(self, key, item_list): ...
    def set_list(self, key='main'): ...
    def eventFilter(self, obj, event): ...
    def do_enter_action(self, item=None): ...
class InventoryWindow:
    def __init__(self, parent=None): ...
    def eventFilter(self, obj, event): ...
    def get_quality(self, game_item): ...
    def label_for(self, game_item): ...
    def update_inventory(self, player): ...
    def update_position(self): ...
    def show_context_menu(self, pos): ...
    def item_double_click(self, item=None): ...
    def drop_item(self, item=None): ...
def main_menu(menu, item, instance, game_instance): ...
def build_menu(menu, item, instance, game_instance): ...
def primary_menu(menu, item, instance, game_instance, list_of_weapons): ...
def skill_menu(menu, item, instance, game_instance, stamina_bound): ...
def debugging_menu(menu, item, instance, game_instance): ...
def player_menu(menu, item, instance, game_instance, npc): ...

# --- From file: ./QtRogueLike/events.py (34 lines) ---
class Event:
    def __init__(self, priority=0): ...
class AttackEvent:
    def __init__(self, attacker, target, damage): ...
class MoveEvent:
    def __init__(self, character, old_x, old_y): ...
class PickupEvent:
    def __init__(self, character, tile): ...
class UseItemEvent:
    def __init__(self, character, item): ...

# --- From file: ./QtRogueLike/mapping.py (903 lines) ---
def GetRandomTile_Reservoir_Sampling(tile_container=None, foreach_tiles=None): ...
def GetRandomTiles_Reservoir_Sampling(tile_container=None, foreach_tiles=None, k=1): ...
class Room:
    def __init__(self): ...
    def get_iterator(self): ...
    def set_tiles_for_positions(self, map_instance, floor_sprite_key='floor'): ...
    def set_tiles_for_boundaries(self, map_instance, wall_sprite_key='wall'): ...
    def add_random_loot(self, loot_table): ...
class Map:
    def __init__(self, filename='default', coords=(0, 0, 0), width=MAP_WIDTH, height=MAP_HEIGHT, b_generate=True, previous_coords=(0, 0, 0), prev_x=MAP_WIDTH // 2, prev_y=MAP_HEIGHT // 2, going_up=False): ...
    def update_buildings_list(self): ...
    def from_dict(self, dictionary): ...
    def generate(self): ...
    def generate_enemy_by_chance_at(self, x, y, enemy=Enemy, chance=1.0, extra_items=None, **kwargs): ...
    def generate_enemy_by_chance_by_list_at(self, x, y, enemy_list): ...
    def generate_enemy_at(self, x, y, enemy_class=None, *args, **kwargs): ...
    def fill_enemies(self, num_enemies=100): ...
    def update_enemies(self, game_instance): ...
    def grid_init_uniform(self, spriteKey='grass', is_walkable=True, x1=0, x2=None, y1=0, y2=None): ...
    def add_rectangle(self, center_x, center_y, width, height, has_entry=True, sprite_border='wall', sprite_floor='floor'): ...
    def add_L_shaped_connectors(self, sprite_corridor_floor='dirt'): ...
    def add_rooms(self, num_rooms=random.randint(8, 15)): ...
    def add_rooms_with_connectors(self, sprite_floor='floor', sprite_corridor_floor='dirt'): ...
    def foreach_rooms_tiles(self, f_lambda=lambda tile, i, j: print((i, j)), *args, **kwargs): ...
    def repaint_floor_rooms(self, sprite='floor'): ...
    def get_random_tile_from_rooms(self): ...
    def get_random_tiles_from_rooms(self, k=20): ...
    def add_patches(self, spriteKey='dirt', is_walkable=True, scale=0.1): ...
    def add_dungeon_loot(self, k=20): ...
    def add_trees(self): ...
    def add_rocks(self, spriteKey='rock', is_walkable=False): ...
    def is_adjacent_walkable(self, tile, x, y): ...
    def is_adjacent_walkable_at(self, x, y): ...
    def get_random_walkable_tile(self, border_factor=0.0): ...
    def add_dungeon_entrance(self, probability=1.0, border_factor=0.0): ...
    def add_dungeon_entrance_at(self, x, y): ...
    def carve_corridor(self, x1, y1, x2, y2, sprite_key='dirt'): ...
    def ensure_connection(self, target_points=None): ...
    def _generate_default(self): ...
    def generate_procedural_forest(self): ...
    def generate_procedural_dungeon(self, previous_map_coords, prev_x, prev_y, up=False): ...
    def generate_procedural_field(self): ...
    def generate_procedural_road(self): ...
    def generate_procedural_lake(self): ...
    def get_tile(self, x, y): ...
    def get_char(self, x, y): ...
    def set_tile(self, x, y, tile): ...
    def can_place_character(self, char): ...
    def can_place_character_at(self, x, y): ...
    def place_character(self, char): ...
    def remove_character(self, char): ...
    def move_character(self, char, dx, dy): ...
    def find_path(self, start_x: int, start_y: int, goal_x: int, goal_y: int): ...
    def _get_sprite_key(self, tile): ...
    def line_of_sight(self, x1, y1, x2, y2): ...

