# --- From file: ./globals_variables.py (212 lines) ---
def Generate_Square_Diffs(radius=3): ...
def d(a=None, b=None): ...
def rn(num=5): ...
H_REST_TURNS = 15
MAP_WIDTH = 70
MAP_HEIGHT = 70
TILE_SIZE = 65
VIEW_WIDTH_IN_TILES = 7
VIEW_HEIGHT_IN_TILES = 9
PLAYER_MAX_HP = 100
PLAYER_MAX_STAMINA = 200
PLAYER_MAX_HUNGER = 1000
PROD_INV_FACTOR = 100.0
POPUP_GUI_ALPHA = 0.8
POPUP_WIDTH = 400
POPUP_HEIGHT = 500
ADJACENT_DIFF_MOVES = [(1, 0), (-1, 0), (0, 1), (0, -1), (0, 0)]
CARDINAL_DIFF_MOVES = [(1, 0), (-1, 0), (0, 1), (0, -1)]
CHESS_KNIGHT_DIFF_MOVES = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
SQUARE_DIFF_MOVES = Generate_Square_Diffs(2)
CROSS_DIFF_MOVES = [(0, 1), (0, 2), (0, 3), (0, -1), (0, -2), (0, -3), (1, 0), (2, 0), (3, 0), (-1, 0), (-2, 0), (-3, 0)]
SPRITE_NAMES_WEAPONS = ['club', 'long_sword', 'bastard_sword', 'mace', 'wand', 'staff', 'crossbow', 'bolt']
SPRITE_NAMES_PLAYABLES = ['player', 'player_2', 'player_3']
SPRITE_NAMES_CHARACTERS = SPRITE_NAMES_PLAYABLES + ['zombie', 'zombie_2', 'bear', 'enemy', 'rogue', 'mercenary', 'swordman', 'mounted_knight', 'evil_swordman', 'crossbowman', 'evil_crossbowman', 'sorceress', 'sorceress_2']
SPRITE_NAMES_FOODS = ['food', 'apple', 'fish', 'bread', 'meat']
SPRITE_NAMES_TILES = ['grass', 'dirt', 'floor', 'wall', 'tree', 'water', 'stair_up', 'stair_down', 'dungeon_entrance', 'shallow_water', 'rock']
SPRITE_NAMES = SPRITE_NAMES_WEAPONS + SPRITE_NAMES_CHARACTERS + SPRITE_NAMES_FOODS + SPRITE_NAMES_TILES + ['sack', 'HUD_arrow', 'whetstone', 'house', 'castle', 'lumber_mill', 'quarry', 'mill', 'wood', 'tower', 'red_flag', 'metal']
HAND_SLOTS = ['primary_hand', 'secondary_hand']
EQUIPMENT_SLOTS = HAND_SLOTS + ['head', 'neck', 'torso', 'waist', 'legs', 'foot']
LOOT_TABLE = [{'item_name': 'Food', 'chance': 0.3, 'name': 'apple', 'nutrition': 10}, {'item_name': 'Food', 'chance': 0.2, 'name': 'fish', 'nutrition': 80}, {'item_name': 'Food', 'chance': 0.1, 'name': 'bread', 'nutrition': 50}, {'item_name': 'Food', 'chance': 0.01, 'name': 'meat', 'nutrition': 280}, {'item_name': 'Sword', 'chance': 0.001, 'name': 'Long_Sword', 'damage': 12, 'durability_factor': 0.998}, {'item_name': 'Sword', 'chance': 0.2, 'name': 'Long_Sword', 'damage': 10, 'durability_factor': 0.95}, {'item_name': 'Sword', 'chance': 0.1, 'name': 'Long_Sword', 'damage': 10, 'durability_factor': 0.8}, {'item_name': 'WeaponRepairTool', 'chance': 0.01, 'name': 'Whetstone', 'uses': 10}]
DUNGEON_ENEMY_TABLE = [{'enemy': 'Mercenary', 'chance': 0.1, 'b_generate_items': True, 'extra_items': [{'item_name': 'WeaponRepairTool', 'name': 'Whetstone', 'uses': 5}, {'item_name': 'Food', 'name': 'meat', 'nutrition': 250}]}, {'enemy': 'Rogue', 'chance': 0.3, 'b_generate_items': True, 'extra_items': [{'item_name': 'WeaponRepairTool', 'name': 'Whetstone', 'uses': 3}, {'item_name': 'Food', 'name': 'meat', 'nutrition': 200}]}, {'enemy': 'Zombie', 'chance': 0.75, 'b_generate_items': True}]
FOREST_ENEMY_TABLE = [{'enemy': 'Bear', 'chance': 0.07, 'b_generate_items': True}, {'enemy': 'Mercenary', 'chance': 0.05, 'b_generate_items': True, 'extra_items': [{'item_name': 'WeaponRepairTool', 'name': 'Whetstone', 'uses': 5}, {'item_name': 'Food', 'name': 'meat', 'nutrition': 250}]}, {'enemy': 'Rogue', 'chance': 0.3, 'b_generate_items': True, 'extra_items': [{'item_name': 'WeaponRepairTool', 'name': 'Whetstone', 'uses': 2}]}, {'enemy': 'Zombie', 'chance': 0.75, 'b_generate_items': True}]
FIELD_ENEMY_TABLE = [{'enemy': 'Bear', 'chance': 0.03, 'b_generate_items': True}, {'enemy': 'Rogue', 'chance': 0.05, 'b_generate_items': True}, {'enemy': 'Zombie', 'chance': 0.9, 'b_generate_items': True}]
DEFAULT_ENEMY_TABLE = [{'enemy': 'Bear', 'chance': 0.03, 'b_generate_items': True}, {'enemy': 'Rogue', 'chance': 0.05, 'b_generate_items': True}, {'enemy': 'Zombie', 'chance': 0.9, 'b_generate_items': True}]
ROAD_ENEMY_TABLE = [{'enemy': 'Rogue', 'chance': 0.1, 'b_generate_items': True}, {'enemy': 'Zombie', 'chance': 0.9, 'b_generate_items': True}]
LAKE_ENEMY_TABLE = [{'enemy': 'Rogue', 'chance': 0.25, 'b_generate_items': True}, {'enemy': 'Zombie', 'chance': 0.75, 'b_generate_items': True}]
TILE_BUILDING_ENEMY_TABLE = [{'enemy': 'Mercenary', 'chance': 0.4, 'b_generate_items': True, 'extra_items': [{'item_name': 'WeaponRepairTool', 'name': 'Whetstone', 'uses': 5}, {'item_name': 'Food', 'name': 'meat', 'nutrition': 250}]}, {'enemy': 'Rogue', 'chance': 0.7, 'b_generate_items': True, 'extra_items': [{'item_name': 'WeaponRepairTool', 'name': 'Whetstone', 'uses': 2}]}]
RAIDERS_TABLE = [{'enemy': 'RangedRaider', 'chance': 0.45, 'b_generate_items': True, 'sprite': 'evil_crossbowman', 'hp': 100}, {'enemy': 'Raider', 'chance': 0.75, 'b_generate_items': True, 'sprite': 'evil_swordman', 'hp': 200}]

# --- From file: ./game.py (1587 lines) ---
class Game_SOUNDMANAGER:
    def __init__(self): ...
    def get_random_music_filename(self, directory='music', pattern=''): ...
    def load_music(self, music_path): ...
    def load_random_music(self): ...
    def handle_media_status(self, status): ...
    def toggle_music(self): ...
class Game_VIEWPORT:
    def __init__(self): ...
    def draw(self): ...
    def get_tiles_to_draw(self): ...
    def is_ingrid(self, x, y): ...
    def is_inview(self, x, y): ...
    def get_anchor(self): ...
    def draw_next_frame(self): ...
    def _get_diff(self, v2, v1): ...
    def draw_animation_on_grid(self, sprite_key, positions): ...
    def draw_grid(self): ...
    def draw_hud(self): ...
    def rotate_vector_for_camera(self, dx, dy): ...
    def rotate_vector_for_movement(self, dx, dy): ...
    def rotated_direction(self, dx, dy): ...
class Game_PLAYERS:
    def __init__(self): ...
    def add_player(self, key, cls_constructor=Player, **kwargs): ...
    def add_hero(self, key, **kwargs): ...
    def set_player(self, name): ...
    def set_player_name(self, key, new_name): ...
    def place_players(self): ...
    def remove_player(self, key=None): ...
    def update_prior_next_selection(self): ...
    def move_party(self): ...
    def release_party(self, diff_moves=CROSS_DIFF_MOVES_1x1): ...
    def release_hero_party(self): ...
    def count_party(self): ...
    def can_select_player(self, player_obj): ...
class Game_MAPTRANSITION:
    def __init__(self): ...
    def player_new_x_y_horizontal(self, out_of_bounds_x, out_of_bounds_y): ...
    def new_map_from_current_coords(self, filename='default', prev_coords=None, up=False): ...
    def map_transition(self, new_map_file, new_map_coord, map_type, prv_coords=None, going_up=False): ...
    def safely_place_character_to_new_map(self, char=None): ...
    def horizontal_map_transition(self, x, y): ...
    def vertical_map_transition(self, target_map_coords, up): ...
class Game_DATA:
    def __init__(self): ...
    def from_dict(self, dictionary): ...
    def start_new_game(self, new_character_name='Main Character', b_clear_players=True): ...
    def save_current_game(self, slot=1): ...
    def try_load_map_or_create_new(self): ...
    def load_current_game(self, slot=1): ...
class Game_GUI:
    def __init__(self): ...
    def add_message(self, message, turns=15): ...
    def update_messages(self): ...
    def update_all_gui(self): ...
    def update_party_window(self): ...
    def update_inv_window(self): ...
    def update_journal_window(self): ...
    def update_behav_window(self): ...
    def take_note_on_diary(self): ...
class Game_ITERATION:
    def __init__(self): ...
    def game_iteration_not_draw(self): ...
    def game_iteration(self): ...
    def process_events(self): ...
    def update_players(self): ...
    def update_enemies(self): ...
    def update_buildings(self): ...
    def Event_NewTurn(self): ...
    def Event_Every_100_Turns(self): ...
    def Event_NewDay(self): ...
    def Event_PlayerDeath(self): ...
    def Event_DoAttack(self, event): ...
    def Event_CharacterDeath(self, event): ...
    def Event_OnLeftMouseClickView(self, x, y): ...
class DraggableView(QGraphicsView):
    def __init__(self, parent=None): ...
    def mousePressEvent(self, event): ...
    def mouseMoveEvent(self, event): ...
    def mouseReleaseEvent(self, event): ...
class WindowSettings(Serializable):
    def __init__(self): ...
class Game(DraggableView, Serializable, Game_VIEWPORT, Game_SOUNDMANAGER, Game_PLAYERS, Game_MAPTRANSITION, Game_DATA, Game_GUI, Game_ITERATION):
    def __init__(self): ...
    def mouseDoubleClickEvent(self, event): ...
    def closeEvent(self, event): ...
    def resizeEvent(self, event): ...
    def keyReleaseEvent(self, event): ...
    def key_press_move_app_window(self, key): ...
    def key_press_cycle_between_playables(self, key): ...
    def key_press_choose_weapon_menu(self, key): ...
    def key_press_gui(self, key): ...
    def player_move_diff(self, dx, dy): ...
    def key_press_movement(self, key): ...
    def mouse_map_pos(self): ...
    def mouse_press_interaction(self): ...
    def mouse_press_movement(self): ...
    def key_press_skills(self, key): ...
    def keyPressEvent(self, event): ...
    def get_mouse_move_diff(self): ...
    def mouseReleaseEvent(self, event): ...

# --- From file: ./gui.py (1346 lines) ---
def item_text_color(game_item): ...
def info(game_item): ...
def new_text(foreground='white', layout=None): ...
def new_button(label, callback=None, foreground='white', layout=None): ...
def new_label(text='', foreground='white', parent=None): ...
def new_list_widget(callback=None, get_filtered_event_from=None): ...
def new_tab_widget(wdg_dict): ...
def new_tab_bar(label='tab 1', callback=None): ...
def add_simple_context_menu(widget, item_list=None, action_callback=lambda x: print(x.text()), **kwargs): ...
def get_widget_list_from_layout(layout, widget_class): ...
def get_slider_list(layout): ...
def get_label_list(layout): ...
def new_slider(minimum=0, maximum=100, value=0, orientation=Qt.Horizontal, layout=None): ...
def new_horizontal_slider(label_text, minimum=0, maximum=100, value=0, layout=None): ...
def set_properties_non_modal_popup(wdg, title): ...
def set_properties_layout(layout): ...
class JournalWindow(Dialog):
    def __init__(self, parent=None): ...
    def build_parts(self): ...
    def update_character_buttons(self): ...
    def update_char_button_images(self): ...
    def assemble_parts(self): ...
    def whereAmI(self): ...
    def update(self): ...
    def update_position(self): ...
    def load_journal(self, slot=1): ...
    def save_journal(self): ...
    def collect_special_text(self): ...
    def generate_quick_entry(self): ...
    def log_quick_diary_entry(self): ...
    def log_diary_entry(self): ...
    def showEvent(self, event): ...
    def append_text(self, text): ...
    def clear_text(self): ...
    def keyPressEvent(self, event): ...
class MessagePopup(Dialog):
    def __init__(self, parent=None): ...
    def set_message(self, messages): ...
class SelectionBox(Widget):
    def __init__(self, item_list=[f'Option {i}' for i in range(5)], action=lambda x, instance: instance.close(), parent=None, **kwargs): ...
    def get_current_list(self): ...
    def add_list(self, key, item_list): ...
    def set_list(self, key='main', item_list=None): ...
    def eventFilter(self, obj, event): ...
    def do_enter_action(self, item=None): ...
class InventoryWindow(Dialog):
    def __init__(self, parent=None): ...
    def build_parts(self): ...
    def update_selected_item_label_content(self, obj=None): ...
    def assemble_parts(self): ...
    def tab_changed(self, index): ...
    def apply_filter(self): ...
    def eventFilter(self, obj, event): ...
    def get_quality(self, game_item): ...
    def label_for(self, game_item): ...
    def update_position(self): ...
    def update_inventory(self, player): ...
    def show_context_menu(self, pos): ...
    def item_double_click(self, item=None): ...
    def drop_item(self, item=None): ...
    def update_row_index(self, last_size, last_index): ...
class BehaviourController(Dialog):
    def __init__(self, parent=None): ...
    def build_parts(self): ...
    def assemble_parts(self): ...
    def on_change_tolerance(self, value): ...
    def on_change_activity(self, value): ...
    def update(self): ...
class PartyWindow(Dialog):
    def __init__(self, parent=None): ...
    def build_parts(self): ...
    def assemble_parts(self): ...
    def update_character_buttons(self): ...
    def update_char_button_images(self): ...
    def update(self): ...
def common_menu_parts(menu, item, instance, game_instance, previous_menu=None): ...
def main_menu(menu, item, instance, game_instance): ...
def build_menu(menu, item, instance, game_instance): ...
def primary_menu(menu, item, instance, game_instance, list_of_weapons, slot): ...
def skill_menu(menu, item, instance, game_instance, stamina_bound): ...
def player_menu(menu, item, instance, game_instance, npc): ...
def debugging_menu(menu, item, instance, game_instance): ...

# --- From file: ./reality.py (2145 lines) ---
def is_enemy_of(char1, char2): ...
class Entity:
    def __init__(self): ...
    def get_transparent_image(self): ...
    def get_sprite(self, rotation=0): ...
    def paint_to(self, painter, game_instance=None): ...
    def distance(self, entity): ...
    def get_tile(self, map): ...
    def place(self, map): ...
class Resource:
    def __init__(self): ...
    def get_value(self): ...
    def update_value(self): ...
    def store(self, char, tile_building): ...
    def get_utility_info(self): ...
class SpecialSkillWeapon:
    def __init__(self): ...
    def consumption(self, char, type): ...
    def calc_damage(self, type): ...
    def special_attack(self, char, target_tile, game, type='knight'): ...
    def use_power_special(self, char, game): ...
    def use_thrust_special(self, char, game): ...
    def use_knight_special(self, char, game): ...
    def use_tower_special(self, char, game): ...
    def use_bishop_special(self, char, game): ...
    def use_special_F(self, char, game): ...
    def use_special_End(self, char, game): ...
class Item(Serializable, Entity):
    def __init__(self, name='', description='', weight=1, sprite='item'): ...
    def paint_to(self, painter, item_list=None): ...
    def get_utility_info(self): ...
    def get_add_info(self): ...
    def __str__(self): ...
    def info(self): ...
    def is_equipped(self, char): ...
class Usable(Item):
    def __init__(self, name='', description='', weight=1, sprite='item', uses=1): ...
    def use(self, char): ...
    def get_utility_info(self): ...
class Ammo(Usable):
    def __init__(self, name='bolt', description='', weight=1, uses=100): ...
    def use(self, char): ...
class Container(Serializable):
    def __init__(self, current_char=None): ...
    def get_item_index(self, item): ...
    def add_item(self, item): ...
    def remove_item(self, item): ...
    def add_item_by_chance(self, item_name, chance=0.1, *args, **kwargs): ...
    def give(self, item, another): ...
class Durable(Item):
    def __init__(self, name='', description='', weight=1, durability_factor=0.995): ...
    def durability_consumption(self, char): ...
    def get_quality(self): ...
    def set_quality(self, n_int=2): ...
    def get_utility_info(self): ...
class Equippable(Durable):
    def __init__(self, name='', description='', weight=1, slot='primary_hand', durability_factor=0.995): ...
    def get_equipped_slot(self, char): ...
    def is_equipped(self, char): ...
    def is_properly_equipped(self, char): ...
    def get_utility_info(self): ...
class Weapon(Equippable):
    def __init__(self, name='', damage=0, description='', weight=1, stamina_consumption=1, durability_factor=0.995): ...
    def durability_consumption(self, char): ...
    def do_stamina_consumption(self, char): ...
    def stats_update(self, player): ...
    def get_utility_info(self): ...
class Fireweapon(Weapon, SpecialSkillWeapon):
    def __init__(self, name='Crossbow', damage=5, description='', weight=1, stamina_consumption=1, durability_factor=0.995, ammo=0, range=12, projectile_sprite='bolt', ammo_type='bolt'): ...
    def perform_attack(self, char, target, positions, game): ...
    def use_special_F(self, char, game): ...
    def do_ammo_consumption(self): ...
    def stats_update(self, player): ...
    def find_target(self, char, game): ...
    def get_utility_info(self): ...
class Parriable(Weapon):
    def __init__(self, name='', damage=0, description='', weight=1, stamina_consumption=1, durability_factor=0.995): ...
    def get_parry_chance(self, char, enemy, damage): ...
class Sword(Parriable, SpecialSkillWeapon):
    def __init__(self, name='long_sword', damage=8, description='', weight=1, stamina_consumption=1, durability_factor=0.995): ...
    def get_parry_chance(self, player, enemy, damage): ...
class Mace(Parriable, SpecialSkillWeapon):
    def __init__(self, name='mace', damage=10, description='', weight=1, stamina_consumption=2, durability_factor=0.995): ...
    def get_parry_chance(self, player, enemy, damage): ...
class Food(Usable, Resource):
    def __init__(self, nutrition=0, name='Meat', description='', weight=1): ...
    def use(self, char): ...
    def update_value(self): ...
    def get_utility_info(self): ...
class Wood(Item, Resource):
    def __init__(self, value=100): ...
    def get_utility_info(self): ...
class Stone(Item, Resource):
    def __init__(self, value=100): ...
    def get_utility_info(self): ...
class Metal(Item, Resource):
    def __init__(self, value=100): ...
    def get_utility_info(self): ...
class WeaponRepairTool(Usable):
    def __init__(self, name='', repairing_factor=1.05, description='', weight=1, uses=10): ...
    def use(self, char): ...
class Armor(Equippable):
    def __init__(self, name='', defense_factor=0.02, description='', weight=1, slot='torso'): ...
    def durability_consumption(self, char): ...
    def get_utility_info(self): ...
class Damageable:
    def __init__(self): ...
    def receive_damage(self, attacker, damage): ...
class OfensiveCharacter(Damageable):
    def __init__(self): ...
    def do_damage(self): ...
    def weapons_stats_update(self): ...
class DefensiveCharacter(OfensiveCharacter):
    def __init__(self): ...
    def receive_damage(self, attacker, damage): ...
    def calculate_defense_factor(self): ...
    def calculate_parry_factor(self, attacker, damage): ...
class RegenerativeCharacter(DefensiveCharacter):
    def __init__(self): ...
    def regenerate(self): ...
    def reset_stats(self): ...
    def regenerate_stamina(self): ...
    def regenerate_health(self): ...
class BehaviourCharacter(Entity):
    def __init__(self): ...
    def get_closest_visible(self, entities, game_instance, default_target=None): ...
    def pursue_target(self, entities, game_instance, default_target=None): ...
    def random_walk(self, game_instance): ...
    def behaviour_update(self, entities, game_instance, default_target=None): ...
class EquippedCharacter(Container):
    def __init__(self): ...
    def equip_item(self, item, slot): ...
    def unequip_item(self, slot): ...
    def pickup_item(self, item): ...
    def generate_initial_items(self): ...
    def set_equipment_by_slot(self, value, slot='primary_hand'): ...
    def get_equipment_by_slot(self, slot='primary_hand'): ...
class Character(EquippedCharacter, BehaviourCharacter):
    def __init__(self, name='', hp=100, x=50, y=50): ...
    def move(self, dx, dy, game_map): ...
    def drop_on_death(self): ...
    def can_see_character(self, another, game_map, max_dist=7): ...
    def use_first_item_of(self, item_class_name, game_instance): ...
    def is_rendered_on_map(self, game_map): ...
    def is_placed_on_map(self, game_map): ...
class SkilledCharacter(Character):
    def __init__(self, name='', hp=100, x=50, y=50): ...
    def dodge_skill(self, game_instance): ...
    def activate_all_skills(self): ...
    def deactivate_all_skills(self): ...
    def update_available_skills(self): ...
class Player(SkilledCharacter, RegenerativeCharacter):
    def __init__(self, name='', hp=PLAYER_MAX_HP, x=MAP_WIDTH // 2, y=MAP_HEIGHT // 2, b_generate_items=False, sprite='player', current_map=(0, 0, 0)): ...
    def move(self, dx, dy, game_map): ...
    def generate_initial_items(self): ...
    def get_forward_direction(self): ...
    def _normalize(self, v): ...
    def _angle(self, v1, v2): ...
    def _signed_angle(self, v1, v2): ...
    def is_in_cone_vision(self, observer, point, direction=(0, -1), fov_deg=180): ...
    def can_see_character(self, another, game_map, max_dist=7): ...
    def update(self, game_instance): ...
    def behaviour_update(self, game_instance): ...
    def update_available_skills(self): ...
    def get_sprite_with_hud(self): ...
    def paint_hp_hud_to(self, painter): ...
    def paint_to(self, painter, game_instance=None): ...
class Healer(Player):
    def __init__(self, name='', hp=PLAYER_MAX_HP, x=MAP_WIDTH // 2, y=MAP_HEIGHT // 2, b_generate_items=False, sprite='player', current_map=(0, 0, 0)): ...
    def behaviour_update(self, game_instance): ...
    def heal_skill(self, target, game_instance): ...
class Hero(Player):
    def __init__(self, name='', hp=PLAYER_MAX_HP, x=MAP_WIDTH // 2, y=MAP_HEIGHT // 2, b_generate_items=False, sprite='player', current_map=(0, 0, 0)): ...
    def add_to_party(self, key, game_instance): ...
    def release_party_member(self, key, game_instance): ...
    def release_party(self, game_instance): ...
    def count_party(self): ...
class Enemy(Character, OfensiveCharacter):
    def __init__(self, name='', hp=30, x=50, y=50, b_generate_items=False): ...
    def behaviour_update(self, game_instance): ...
class Raider(Enemy):
    def __init__(self, name='', hp=30, x=50, y=50, b_generate_items=False, sprite='enemy'): ...
    def pursue_target(self, entities, game_instance, default_target=None): ...
    def behaviour_update(self, game_instance): ...
    def generate_initial_items(self): ...
class RangedRaider(Raider):
    def __init__(self, name='', hp=30, x=50, y=50, b_generate_items=False, sprite='enemy'): ...
    def generate_initial_items(self): ...
class Zombie(Enemy):
    def __init__(self, name='', hp=40, x=50, y=50, b_generate_items=False): ...
    def do_damage(self): ...
    def generate_initial_items(self): ...
class Rogue(Enemy):
    def __init__(self, name='', hp=100, x=50, y=50, b_generate_items=False): ...
    def generate_initial_items(self): ...
class Mercenary(Rogue):
    def __init__(self, name='', hp=130, x=50, y=50, b_generate_items=False): ...
    def generate_initial_items(self): ...
class Bear(Enemy):
    def __init__(self, name='', hp=80, x=50, y=50, b_generate_items=False): ...
    def generate_initial_items(self): ...
class Tile(Container):
    SPRITES = {}
    def __init__(self, x=0, y=0, walkable=True, sprite_key='grass'): ...
    def add_layer(self, sprite_key): ...
    def get_transparent_image(self): ...
    def paint_items(self, painter): ...
    def draw(self, scene, x, y, tile_size=TILE_SIZE, extra_pixmap=None, game_instance=None): ...
    def can_place_character(self): ...
    def get_default_pixmap(self): ...
    def add_cosmetic_sprite(self, sprite_key=None): ...
    def get_stamina_consumption(self): ...
    def get_layer_index(self, sprite_name): ...
    def add_layer_if_not_already(self, sprite_name): ...
    def remove_layer(self, sprite_name): ...
    def is_grass(self): ...
    def is_rock(self): ...
    def is_water(self): ...
    def is_forest(self): ...
    def get_rotated_sprite(cls, key, rotation=0): ...
    def get_random_sprite(cls, key_filter=''): ...
    def _try_load(cls, key, size=TILE_SIZE): ...
    def _load_sprites(cls): ...
class ActionTile(Tile):
    def __init__(self, x=0, y=0, front_sprite='stair_up', walkable=True, sprite_key='grass'): ...
class Stair(ActionTile):
    def __init__(self, x=0, y=0, front_sprite='stair_up', walkable=True, sprite_key='grass'): ...
class TileBuilding(ActionTile):
    def __init__(self, x=0, y=0, front_sprite='Castle', walkable=True, sprite_key='grass', b_enemy=False): ...
    def clear_resources(self): ...
    def bonus_resources(self): ...
    def production(self, multiplier=1.0): ...
    def update(self, game_instance=None): ...
    def retrieve_food(self, game_instance, quantity=500): ...
    def retrieve_wood(self, game_instance, quantity=500): ...
    def retrieve_metal(self, game_instance, quantity=500): ...
    def retrieve_stone(self, game_instance, quantity=500): ...
    def store_resource(self, res, char): ...
    def menu_garrison(self, current_menu, current_item, menu_instance, game_instance): ...
    def menu_resources(self, current_menu, current_item, menu_instance, game_instance): ...
    def set_population_menu(self, menu_instance): ...
    def refresh_game_instance(self, x, y, game_instance): ...
class Castle(TileBuilding):
    def __init__(self, x=0, y=0, name='Home', b_enemy=False): ...
    def production(self, multiplier=1.0): ...
    def action(self): ...
    def update_menu_list(self, selection_box_instance=None): ...
    def new_hero(self, game_instance): ...
    def new(cls, game_instance, x=None, y=None): ...
class Mill(TileBuilding):
    def __init__(self, x=0, y=0, name='Farm', food=d(500, 2000), b_enemy=False): ...
    def action(self): ...
    def update_menu_list(self, selection_box_instance=None): ...
    def production(self, multiplier=1.0): ...
class LumberMill(TileBuilding):
    def __init__(self, x=0, y=0, name='Lumber Mill', wood=d(500, 2000), b_enemy=False): ...
    def action(self): ...
    def update_menu_list(self, selection_box_instance=None): ...
    def production(self, multiplier=1.0): ...
class GuardTower(TileBuilding):
    def __init__(self, x=0, y=0, name='Guard Tower', b_enemy=False): ...
    def action(self): ...
    def update_menu_list(self, selection_box_instance=None): ...
    def new_swordman(self, game_instance): ...
    def new_mounted_knight(self, game_instance): ...
    def new_crossbowman(self, game_instance): ...
    def production(self, multiplier=1.0): ...

# --- From file: ./mapping.py (944 lines) ---
def GetRandomTile_Reservoir_Sampling(tile_container=None, foreach_tiles=None): ...
def GetRandomTiles_Reservoir_Sampling(tile_container=None, foreach_tiles=None, k=1): ...
class Room:
    def __init__(self): ...
    def get_iterator(self): ...
    def set_tiles_for_positions(self, map_instance, floor_sprite_key='floor'): ...
    def set_tiles_for_boundaries(self, map_instance, wall_sprite_key='wall'): ...
    def add_random_loot(self, loot_table): ...
class Map_MODELLING:
    def __init__(self): ...
    def grid_init_uniform(self, spriteKey='grass', is_walkable=True, x1=0, x2=None, y1=0, y2=None): ...
    def add_rectangle(self, center_x, center_y, width, height, has_entry=True, sprite_border='wall', sprite_floor='floor'): ...
    def add_L_shaped_connectors(self, sprite_corridor_floor='dirt'): ...
    def add_rooms(self, num_rooms=random.randint(8, 15)): ...
    def add_rooms_with_connectors(self, sprite_floor='floor', sprite_corridor_floor='dirt'): ...
    def foreach_rooms_tiles(self, f_lambda=lambda tile, i, j: print((i, j)), *args, **kwargs): ...
    def repaint_floor_rooms(self, sprite='floor'): ...
    def add_patches(self, spriteKey='dirt', is_walkable=True, scale=0.1): ...
    def add_trees(self): ...
    def add_rocks(self, spriteKey='rock', is_walkable=False): ...
    def carve_corridor(self, x1, y1, x2, y2, sprite_key='dirt'): ...
    def ensure_connection(self, target_points=None): ...
class Map_SPECIAL:
    def __init__(self): ...
    def add_enemy_mill(self, probability=0.3, border_factor=0.0, quantity=1): ...
    def add_enemy_lumber_mill(self, probability=0.3, border_factor=0.0, quantity=1): ...
    def add_enemy_tower(self, probability=0.3, border_factor=0.0, quantity=1): ...
    def add_dungeon_entrance(self, probability=1.0, border_factor=0.0): ...
    def add_dungeon_entrance_at(self, x, y): ...
    def add_dungeon_loot(self, k=20): ...
    def add_stair_down_by_chance(self, probability=0.5, excluded=None): ...
class Map_CHARACTERS:
    def __init__(self): ...
    def get_char(self, x, y): ...
    def generate_enemy_by_chance_at(self, x, y, enemy=Enemy, chance=1.0, extra_items=None, **kwargs): ...
    def generate_enemy_by_chance_by_list_at(self, x, y, enemy_list): ...
    def generate_enemy_at(self, x, y, enemy_class=None, *args, **kwargs): ...
    def fill_enemies(self, num_enemies=100): ...
    def has_adjacent_walkable_can_place_character(self, tile, x, y): ...
    def all_adjacent_walkable_can_place_character(self, tile, x, y): ...
    def update_enemies(self, game_instance): ...
    def can_place_character(self, char): ...
    def can_place_character_at(self, x, y): ...
    def place_character(self, char): ...
    def remove_character(self, char): ...
    def move_character(self, char, dx, dy): ...
    def find_entity_path(self, entity_1, entity_2): ...
    def find_path(self, start_x: int, start_y: int, goal_x: int, goal_y: int): ...
    def line_of_sight(self, x1, y1, x2, y2): ...
class Map_TILES:
    def __init__(self): ...
    def get_random_tile_from_rooms(self): ...
    def get_random_tiles_from_rooms(self, k=20): ...
    def is_xy_special(self, x, y): ...
    def is_walkable(self, x, y): ...
    def has_adjacent_walkable(self, tile, x, y): ...
    def is_adjacent_walkable(self, tile, x, y): ...
    def is_adjacent_walkable_at(self, x, y): ...
    def get_random_walkable_tile(self, border_factor=0.0): ...
    def get_tile(self, x, y): ...
    def set_tile(self, x, y, tile): ...
    def _get_sprite_key(self, tile): ...
    def find_stair_tile_xy(self, target_stair_coords): ...
class Map(Serializable, Map_SPECIAL, Map_MODELLING, Map_CHARACTERS, Map_TILES):
    def __init__(self, filename='default', coords=(0, 0, 0), width=MAP_WIDTH, height=MAP_HEIGHT, b_generate=False, previous_coords=(0, 0, 0), prev_x=MAP_WIDTH // 2, prev_y=MAP_HEIGHT // 2, going_up=False): ...
    def from_dict(self, dictionary): ...
    def update_buildings_list(self): ...
    def generate(self): ...
    def _generate_default(self): ...
    def generate_procedural_forest(self): ...
    def generate_procedural_dungeon(self, previous_map_coords, prev_x, prev_y, up=False): ...
    def generate_procedural_field(self): ...
    def generate_procedural_road(self): ...
    def generate_procedural_lake(self): ...

# --- From file: ./events.py (34 lines) ---
class Event:
    def __init__(self, priority=0): ...
class AttackEvent(Event):
    def __init__(self, attacker, target, damage): ...
class MoveEvent(Event):
    def __init__(self, character, old_x, old_y): ...
class PickupEvent(Event):
    def __init__(self, character, tile): ...
class UseItemEvent(Event):
    def __init__(self, character, item): ...

# --- From file: ./pyqt_layer_framework.py (149 lines) ---
def color_to_css(foreground): ...
def set_relative_horizontal_position(widget, widget_reference, side='right', gap=10): ...
def set_relative_vertical_position(widget, widget_reference, side='down', gap=5): ...
def set_text_cursor_to(text_widget, position=QTextCursor.End): ...
def apply_filter_to_list_widget(list_widget, text): ...
def clear_layout(layout): ...
def is_widget_in_list(list_widget: QListWidget, widget: QWidget): ...
class VLayout(QVBoxLayout):
    def __truediv__(self, other): ...
class HLayout(QHBoxLayout):
    def __truediv__(self, other): ...
class Dialog(QDialog):
    def __truediv__(self, other): ...
class Widget(QWidget):
    def __truediv__(self, other): ...
    def __add__(self, other): ...
    def __sub__(self, other): ...
class DraggableWidget(Widget):
    def __init__(self, parent=None): ...
    def mousePressEvent(self, event): ...
    def mouseMoveEvent(self, event): ...
    def mouseReleaseEvent(self, event): ...

# --- From file: ./start.pyw (208 lines) ---
def add_alias(alias, root): ...
def is_node_import_restricted(node): ...
def is_node_call_restricted(node): ...
def is_node_attr_restricted(node): ...
def is_node_dynamic_import(node): ...
def is_node_string_injection_with_dynamic_import(node): ...
def is_module_safe(path): ...
def import_module_from_path(path, module_name=None): ...

# --- From file: ./serialization.py (238 lines) ---
class Serializable:
    def __init__(self): ...
    def __init_subclass__(cls, **kwargs): ...
    def to_dict(self): ...
    def from_dict(self, dictionary): ...
    def Save_JSON(self, filename): ...
    def Load_JSON(self, filename): ...
    def _serialize(self, value): ...
    def _deserialize(self, value, target): ...
    def set_ignored_keys(self, keys): ...
    def append_ignored_keys(self, *keys): ...
    def set_serialized_keys(self, keys): ...
    def get_ignored_keys(self): ...
    def get_serialized_keys(self): ...
    def _get_class_by_name(name): ...

# --- From file: ./performance.py (45 lines) ---
def tic(): ...
def toc(initial, message='', t_bound=0.25): ...

# --- From file: ./artificial_behavior.py (611 lines) ---
class Function_Family:
    def __init__(self, function=None): ...
    def __call__(self, *args, **kwargs): ...
class Conditional_Network(Function_Family):
    def __init__(self, function=None): ...
    def __add__(self, another): ...
    def __mul__(self, another): ...
    def __neg__(self): ...
    def __sub__(self, another): ...
    def __invert__(self): ...
    def __truediv__(self, another): ...
    def __eq__(self, other): ...
    def __repr__(self): ...
def is_enemy_of(char1, char2): ...
def get_closest_visible(origin=None, default_target=None, entities=None, game_instance=None): ...
def AB_random_walk(char=None, game_instance=None): ...
def AB_ranged_attack(char=None, game_instance=None): ...
def AB_melee_current_target(char=None, game_instance=None): ...
def AB_heal_current_target(char=None, game_instance=None): ...
def AB_pillage_current_target(char=None, game_instance=None): ...
def AB_melee_attack(char=None, game_instance=None): ...
def AB_healing(char=None, game_instance=None): ...
def AB_pillage(char=None, game_instance=None): ...
def AB_pursue_current_target(char=None, game_instance=None): ...
def AB_pursue_current_target_building(char=None, game_instance=None): ...
def AB_pursue_current_target_healing(char=None, game_instance=None): ...
def AB_pursue_current_target_tile(char=None, game_instance=None): ...
def AB_find_melee_target(char=None, game_instance=None): ...
def AB_find_melee_target_grudge(char=None, game_instance=None): ...
def AB_find_healing_target(char=None, game_instance=None): ...
def AB_find_building_target(char=None, game_instance=None): ...
def AB_find_random_tile_target(char=None, game_instance=None): ...
def AB_behavior_default(char=None, game_instance=None): ...
def AB_behavior_grudge(char=None, game_instance=None): ...
def AB_behavior_raider(char=None, game_instance=None): ...
def AB_behavior_healer(char=None, game_instance=None): ...

# --- TOTAL: (7519 lines) ---
